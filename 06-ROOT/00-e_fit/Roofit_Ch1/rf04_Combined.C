#include "RooRealVar.h"
#include "RooDataSet.h"
#include "RooGaussian.h"
#include "RooChebychev.h"
#include "RooAddPdf.h"
#include "RooWorkspace.h"
#include "RooPlot.h"
#include "TCanvas.h"
#include "TAxis.h"
#include "TFile.h"
#include "TH1.h"
using namespace RooFit;

#include "TMath.h"  // keep with your other includes

// Format "(v ± e) × 10^{exp}" using a common exponent from max(|v|,|e|).
// nd = number of decimals on the mantissas. 
// omit10pow0=true hides "×10^{0}" when the exponent is 0.
static TString FormatYieldSci(const char* texName,
                              double val, double err,
                              int nd=1, bool omit10pow0=true)
{
  const double amax = TMath::Max(TMath::Abs(val), TMath::Abs(err));
  const int    exp10 = (amax>0.0) ? (int)TMath::Floor(TMath::Log10(amax)) : 0;
  const double scale = TMath::Power(10.0, exp10);
  const double vm = (scale!=0.0) ? val/scale : 0.0;
  const double em = (scale!=0.0) ? err/scale : 0.0;

  TString vStr, eStr, out;
  vStr.Form("%.*f", nd, vm);
  eStr.Form("%.*f", nd, em);

  if (omit10pow0 && exp10==0) {
    out.Form("%s = (%s #pm %s)", texName, vStr.Data(), eStr.Data());
  } else {
    out.Form("%s = (%s #pm %s) * 10^{%d}",
             texName, vStr.Data(), eStr.Data(), exp10);
  }
  return out;
}

// return "a#times10^{b}" with 'sig' significant figures (TLatex friendly)
static TString Sci2Sig(double v, int sig = 2) {
  if (!(v > 0.0) || !std::isfinite(v)) return "0";
  double av = std::fabs(v);
  int    e  = (int)std::floor(std::log10(av));
  double m  = av / std::pow(10.0, e);

  // round mantissa to 'sig' sig figs
  double r = std::pow(10.0, sig - 1);
  m = std::round(m * r) / r;
  if (m >= 10.0) { m /= 10.0; ++e; }

  // strip trailing zeros
  TString ms; ms.Form("%.*f", sig - 1, m);
  while (ms.EndsWith("0")) ms.Chop();
  if (ms.EndsWith(".")) ms.Chop();

  TString out;
  if (e != 0) out.Form("%s*10^{%d}", ms.Data(), e);
  else        out = ms;
  return out;
}
 
void rf04_Combined()
{
  // S e t u p   t h e   F r a m e   f o r   t h e   P l o t
  //------------------------------------------------------------
  // Canvas & pads
  TCanvas *c = new TCanvas("fit", "fit", 700, 760);

  // 72% top pad (main), 28% bottom pad (pull)
  TPad *pad1 = new TPad("pad1","pad1",0,0.28,1,1);
  TPad *pad2 = new TPad("pad2","pad2",0,0,1,0.28);

  // Main pad: leave room at the top for labels
  pad1->SetTopMargin(0.16);     // was 0.05
  pad1->SetBottomMargin(0.03);  // tighter gap to pull
  pad1->SetLeftMargin(0.15);
  pad1->SetRightMargin(0.06);
  pad1->SetTicks(1,1);

  // Pull pad: smaller top margin so panels “kiss”
  pad2->SetTopMargin(0.02);     // was 0.01
  pad2->SetBottomMargin(0.38);  // keep room for big x-title
  pad2->SetLeftMargin(0.15);
  pad2->SetRightMargin(0.06);
  pad2->SetTicks(1,1);

  pad1->Draw();
  pad2->Draw();
  pad1->cd();
  gStyle->SetOptStat(0);
  gStyle->SetEndErrorSize(0);
  pad1->SetTicks(1,1);
  pad2->SetTicks(1,1);
  //=========================================================================================================================================================================//
  // R e a d   w o r k s p a c e   f r o m   f i l e
  // -----------------------------------------------
  // Open input file with workspace (generated by rf503_wspacewrite)
  TFile *f_Sig = new TFile("/home/belle2/amubarak/Ds2D0enue_Analysis/05-ROOT/00-e_fit/Roofit_Ch1/Fit_Parameter/rf00_Signal.root");
  TFile *f_Dstarp = new TFile("/home/belle2/amubarak/Ds2D0enue_Analysis/05-ROOT/00-e_fit/Roofit_Ch1/Fit_Parameter/rf01_Dstarplus.root");
  TFile *f_Dstar0 = new TFile("/home/belle2/amubarak/Ds2D0enue_Analysis/05-ROOT/00-e_fit/Roofit_Ch1/Fit_Parameter/rf02_Dstar0.root");

  // R e t r i e v e   p d f   f r o m   w o r k s p a c e
  // -----------------------------------------------------------------
  // Signal
  RooWorkspace *w_S = (RooWorkspace *)f_Sig->Get("w_Sig");
  // RooRealVar *M_S = w_S->var("Ds_diff_D0pi");
  RooAbsPdf *SignalModel = w_S->pdf("SignalModel");

  // Peaking Background
  RooWorkspace *w_DstarP = (RooWorkspace *)f_Dstarp->Get("w_Dstarp");
  // RooRealVar *M_PBkg = w_PBkg->var("Ds_diff_D0pi");
  RooAbsPdf *DstarpBkgModel = w_DstarP->pdf("DstarpModel");

  // Combinatorial + Failed Background
  RooWorkspace *w_Dstar0 = (RooWorkspace *)f_Dstar0->Get("w_Dstar0");
  // RooRealVar *M_CFBkg = w_CFBkg->var("Ds_diff_D0pi");
  RooAbsPdf *Dstar0BkgModel = w_Dstar0->pdf("Dstar0Model");

  w_S->loadSnapshot("reference_fit_Signal");
  w_DstarP->loadSnapshot("reference_fit_Dstarp");
  w_Dstar0->loadSnapshot("reference_fit_Dstar0");
  //=========================================================================================================================================================================//
  // I n i t i a l i z a t i o n:
  // --------------------------------------------------------------
  // The lines below initializes all my values
  int bin = 50;
  double xL = 0.00;
  double xR = 0.25;
  //=========================================================================================================================================================================//
  // I m p o r t s   D a t a   f r o m   t r e e   b r a n c h:
  // --------------------------------------------------------------
  TFile *file = new TFile("/group/belle/users/amubarak/03-ML/BkgBDT/Ds2D0e-Generic_Ds_053025_0_All_withBkgBDT.root");
  TTree *tree = (TTree*)file->Get("Dstree");
  //=========================================================================================================================================================================//
  // D a t a:
  // --------------------------------------------------------------
  RooRealVar x("Ds_massDifference_0", "Mass Difference", xL, xR);
  RooRealVar BS("Ds_BkgBDT", "Background Suppression", 0, 1);
  RooDataSet data("data", "dataset with mass", tree, RooArgSet(x,BS));

  // Apply multiple selection cuts: 
  RooDataSet *filteredData = (RooDataSet*)data.reduce("Ds_BkgBDT >= 0.7");
  //=========================================================================================================================================================================//
  // C r e a t e   C o m b i n e d   M o d e l
  // ------------------------------------------------------------------------------

  //  // Signal
  //  //=============================
  // //  RooKeysPdf SignalModel("SignalModel","keys", x, *filteredData, RooKeysPdf::MirrorBoth, 2.0); // rho≈2 matches your smooth curve well

  //  // D^*+
  //  //=============================
  //  // Core (red in your sketch)
  //  RooRealVar Dstarp_m1 ("Dstarp_m1","core mean", 8.4760e-02, 7.4760e-02, 9.4760e-02);
  //  RooRealVar Dstarp_sL1("Dstarp_sL1","core σL",  1.7869e-02, 0.7869e-02, 2.7869e-02);
  //  RooRealVar Dstarp_sR1("Dstarp_sR1","core σR",  2.5693e-03, 1.5693e-03, 3.5693e-03);
  //  RooRealVar Dstarp_aL1("Dstarp_aL1","αL",       5.1614e+00, 4.1614e+00, 6.1614e+00);
  //  RooRealVar Dstarp_nL1("Dstarp_nL1","nL",       4.3582e+01, 3.3582e+01, 5.3582e+01);
  //  RooRealVar Dstarp_aR1("Dstarp_aR1","αR",       1.9574e+00, 0.9574e+00, 2.9574e+00);
  //  RooRealVar Dstarp_nR1("Dstarp_nR1","nR",       1.3230e+00, 0.3230e+00, 2.3230e+00);
  //  RooCrystalBall Dstarp_core("Dstarp_core","DSCB", x,
  //  Dstarp_m1, Dstarp_sL1, Dstarp_sR1, Dstarp_aL1, Dstarp_nL1, Dstarp_aR1, Dstarp_nR1);

  //  // Shoulder (green in your sketch)
  //  RooRealVar Dstarp_m2 ("Dstarp_m2","shelf mean", 4.8662e-02, 3.8662e-02, 5.8662e-02);
  //  RooRealVar Dstarp_sL2("Dstarp_sL2","shelf σL",  2.1446e-03, 1.1446e-03, 3.1446e-03);
  //  RooRealVar Dstarp_sR2("Dstarp_sR2","shelf σR",  1.2664e-02, 0.2664e-02, 2.2664e-02);
  //  RooBifurGauss Dstarp_shelf("Dstarp_shelf","bifurG", x, Dstarp_m2, Dstarp_sL2, Dstarp_sR2);

  //  // Mix
  //  RooRealVar Dstarp_f ("Dstarp_f","frac core", 7.4134e-01, 0.5, 0.95);
  //  RooAddPdf  DstarpBkgModel("DstarpBkgModel","DSCB + bifurG", RooArgList(Dstarp_core, Dstarp_shelf), RooArgList(Dstarp_f));

  //  // D^*0
  //  //=============================
  //  // First Johnson (core)
  //  RooRealVar delta1Dstar0("delta1Dstar0", "delta1", 6.2145e+00, 5.2145e+00, 7.2145e+00);
  // //  delta1Dstar0.setConstant(true);
  //  RooRealVar gamma1Dstar0("gamma1Dstar0", "gamma1", -3.8423e+00, -4.8423e+00, -2.8423e+00);
  //  RooRealVar mean1Dstar0("mean1Dstar0", "Johnson mean", 1.4531e-08, 0.4531e-08, 2.4531e-08);
  // //  mean1Dstar0.setConstant(true);
  //  RooRealVar sigma1Dstar0("sigma1Dstar0", "sigma1", 8.4820e-02, 7.4820e-02, 9.4820e-02);
  //  RooJohnson j1Dstar0("j1Dstar0", "Johnson core", x, mean1Dstar0, sigma1Dstar0, gamma1Dstar0, delta1Dstar0);

  //  // Second Johnson (tail)
  //  RooRealVar delta2Dstar0("delta2Dstar0", "delta2", 7.0773e+00, 6.0773e+00, 8.0773e+00);
  // //  delta2Dstar0.setConstant(true);
  //  RooRealVar gamma2Dstar0("gamma2Dstar0", "gamma2", 1.6851e+00, 0.6851e+00, 2.6851e+00);
  //  RooRealVar mean2Dstar0("mean2Dstar0", "Johnson mean", 1.5997e-01, 0.5997e-01, 2.5997e-01);
  // //  mean2Dstar0.setConstant(true);
  //  RooRealVar sigma2Dstar0("sigma2", "sigma2", 1.5135e-01, 0.5135e-01, 2.5135e-01);
  //  RooJohnson j2Dstar0("j2Dstar0", "Johnson tail", x, mean2Dstar0, sigma2Dstar0, gamma2Dstar0, delta2Dstar0);

  //  // Weight between the two Johnson components
  //  RooRealVar fDstar0("fDstar0", "Fraction of j1", 9.2735e-01, 8.2735e-01, 10.2735e-01);

  //  // Combine Johnsons
  //  RooAddPdf Dstar0BkgModel("Dstar0BkgModel", "j1 + j2", RooArgList(j1Dstar0, j2Dstar0), RooArgList(fDstar0));

  // Comb.
  //=============================
  // RooRealVar a("a", "power shape", 8.8299e-03, 7.8299e-03, 9.8299e-03);          // sharpness of turn-on
  // RooRealVar b("b", "tail weight", 7.3664e-03, 6.3664e-03, 8.3664e-03);           // plateau slope
  // RooRealVar c_shape("c_shape", "width scale", 1.2816e-02, 0.2816e-02, 2.2816e-02);     // saturation scale
  // RooRealVar dm0("dm0", "threshold", 1.1988e-02, 0.1988e-02, 2.1988e-02);  // turn-on
  // a.setConstant(true);
  // b.setConstant(true);
  // c_shape.setConstant(true);
  // dm0.setConstant(true);
  // RooDstD0BG Combinatorial("Combinatorial", "Combinatorial background", x, dm0, c_shape, a, b);

  RooRealVar x00("x00","x00", 1.3494e-02, 1.0e-02, 1.5e-02);
  RooRealVar a0("a0","a0", 5.7898e-01, 4.7898e-01, 6.7898e-01);
  RooRealVar b0("b0","b0", 3.0263e+00, 2.0263e+00, 4.0263e+00);    
  // x00.setConstant(true);
  // a0.setConstant(true);
  // b0.setConstant(true);
  RooFormulaVar x00prime("#x00prime", "x[0] < x[1] ? x[0] : x[1]", RooArgList(x, x00));     
  RooFormulaVar gamma0("#gamma0", "a0 + 1", RooArgList(a0));    
  RooFormulaVar beta0_for_gamma("beta0_for_gamma", "1./b0", RooArgList(b0));    
  RooGamma Combinatorial("Combinatorial", "Gamma pdf", x, gamma0, beta0_for_gamma, x00prime);

  //--------------- Combined Model of signal and generic MC ------------------//
  //--------------------------------------------------------------------------//
  RooRealVar f0("f0", "f0", 0, 0.0, 50.);
  // RooRealVar f1("f1", "f1", 4.4376e+04, 4.0e+04, 5.0e+04);
  // RooRealVar f2("f2", "f2", 1.2666e+04, 1.0e+04, 1.5e+04);

  // Fixed Yield
  RooRealVar f1("f1", "f1", 4.4465e+04, 4.0e+04, 5.0e+04);
  RooRealVar f2("f2", "f2", 1.3752e+04, 1.0e+04, 1.5e+04);
  f1.setConstant(true);
  f2.setConstant(true);

  RooRealVar f3("f3", "f3", 5.5672e+04, 5.0e+04, 6.0e+04);
  // f0.setConstant(true);
  // f1.setConstant(true);
  // f2.setConstant(true);
  // f3.setConstant(true);
  // RooAddPdf model("model", "s+pbkg+cbkg+fs", RooArgList(*SignalModel,DstarpBkgModel,Dstar0BkgModel, Combinatorial), RooArgList(f0,f1,f2,f3));
  RooAddPdf model("model", "s+pbkg+cbkg+fs", RooArgList(*SignalModel,*DstarpBkgModel,*Dstar0BkgModel, Combinatorial), RooArgList(f0,f1,f2,f3));
  //=========================================================================================================================================================================//
  // F i t
  //-------------
  // Perform extended ML fit of data:
  std::unique_ptr<RooFitResult> r{model.fitTo(*filteredData, Save(), PrintLevel(-1))};
  // If the fit is too broad and does not seem to fit a peak use the code below. Use it
  // once to determine where the peak should be and then adjust the mean above.
  // model.fitTo(data, Minos(kTRUE), PrintLevel(-1), Range(2,2.1));
  //=========================================================================================================================================================================//
  // P l o t 
  //---------
  RooPlot* frame = x.frame();
  filteredData->plotOn(frame, Binning(bin));

  // =================== signal overlay (theory OR fit×factor) ========
  constexpr double K_VIS  = 5.0e5;    // pick a value that makes the curve visible
  constexpr double BF_REF = 3e-8;     // theory BF you want to illustrate

  // Inputs (your numbers)
  const double L_nb      = 1.443999e18;  // nb^{-1}  (≈1.444 ab^{-1})
  const double sigma_nb  = 1.329e-9;     // nb
  const double two_f_Ds  = 0.20;         // 2·f(c→Ds)
  const double Br_D0_Kpi = 0.03947;      // B(D0→Kπ)
  const double eff_scal  = 0.0415181;      // signal efficiency for this selection

  // Expected signal yield at BF_REF
  const double N_theory = L_nb * sigma_nb * two_f_Ds * Br_D0_Kpi * eff_scal * BF_REF;

  // ----- Draw ONLY the signal SHAPE, normalized to K_VIS × N_theory -----
  SignalModel->plotOn(frame,
    RooFit::Components("SignalModel"),               // your signal component name
    RooFit::Normalization(K_VIS * N_theory, RooAbsReal::NumEvent),
    RooFit::LineStyle(kDashed),
    RooFit::LineColor(kAzure-2),
    RooFit::Name("sigVis"));
  // =================== individual components (optional) =============

  model.plotOn(frame, Components(*DstarpBkgModel),     LineStyle(kDashed), LineColor(kGreen+1),    RooFit::Name("DstarP"));
  model.plotOn(frame, Components(*Dstar0BkgModel),     LineStyle(kDashed), LineColor(kOrange+8),   RooFit::Name("Dstar0"));
  model.plotOn(frame, Components(Combinatorial),       LineStyle(kDashed), LineColor(kViolet-3),   RooFit::Name("Comb"));

  model.plotOn(frame, LineColor(41), RooFit::Name("model"));
  // *PeakingBkgModel->plotOn(frame, LineColor(38), RooFit::Name("model"));
  //=========================================================================================================================================================================//
  // C a l c u l a t e   c h i ^ 2
  // ------------------------------
  // Show the chi^2 of the curve w.r.t. the histogram
  // If multiple curves or datasets live in the frame you can specify
  // the name of the relevant curve and/or dataset in chiSquare()
  Int_t npar = model.getParameters(*filteredData)->selectByAttrib("Constant",kFALSE)->getSize(); //select floating parameters and count their number

  cout << "NDF = " << npar << endl;
  cout << "chi^2/NDF = " << frame->chiSquare(npar) << endl;

  Double_t chi2ndf = frame->chiSquare(npar);
  //=========================================================================================================================================================================//
  // P l o t    L a b e l s
  // ---------------------------------------------------------------------------
  // // // Add text to frame
  // // TLatex *latex = new TLatex();
  // // TString lum ("");
  // // lum.Form("#splitline{Simulated Events}{2M Events}");
  // // latex->SetNDC();
  // // latex->SetTextSize(0.035);
  // // Add text to frame
  // TLatex *latex = new TLatex();
  // TString lum ("");
  // // lum.Form("#splitline{Simulation}{200k Events}");
  // lum.Form("#splitline{Generic Events}{#scale[0.5]{#int}#it{L} dt=1.4 ab^{-1}}");
  // latex->SetNDC();
  // latex->SetTextSize(0.035); 

  auto PerBin = ((xR-xL)/(bin))*1000;
  // TString title ("");
  TString y_axis ("");
  // TString x_axis ("");

  // title.Form("Generic d#bar{d} Events");
  y_axis.Form("Entries/(%.2f MeV/c^{2})", PerBin);
  // x_axis.Form("#Delta m  [GeV/c^{2}]");

  frame->SetTitle("");

  // ---- Make negative overlay visible if needed ----
  const double maxY = frame->GetMaximum();
  frame->GetYaxis()->SetRangeUser(0.0, 1.35*maxY);   // show a bit below zero

  frame->GetYaxis()->SetTitleFont(132);
  frame->GetYaxis()->SetLabelFont(132);
  frame->GetXaxis()->SetTitleFont(132);
  frame->GetXaxis()->SetLabelFont(132);

  // Y (main)
  frame->GetYaxis()->SetTitle(y_axis);
  frame->GetYaxis()->SetTitleSize(0.060);    // bigger title
  frame->GetYaxis()->SetLabelSize(0.045);    // bigger labels
  frame->GetYaxis()->SetTitleOffset(1.1);   // move left a touch

  // Hide X title/labels on main (they live in the pull panel)
  frame->GetXaxis()->SetTitle("");
  frame->GetXaxis()->SetLabelSize(0.0);

  frame->Draw();

  auto y0 = new TLine(xL, 0.0, xR, 0.0);
  y0->SetLineStyle(kDashed); y0->SetLineColor(kGray+1);
  y0->Draw("same");

  const double xRight = 1.0 - pad1->GetRightMargin() - 0.005;
  const double xLeft  = pad1->GetLeftMargin()  + 0.005;
  const double yBand  = 1.0 - 0.5*pad1->GetTopMargin();  // middle of top margin

  TLatex *latex = new TLatex();
  latex->SetNDC();
  latex->SetTextFont(132);
  latex->SetTextSize(0.060);  // slightly larger

  // Right, top
  latex->SetTextAlign(33);
  latex->DrawLatex(xRight, yBand, "#scale[0.5]{#int}#it{L} dt=1.4 ab^{-1}");

  // Left, top
  latex->SetTextAlign(13);
  latex->DrawLatex(xLeft,  yBand, "Generic Events");

  // The line below prints the luminosity onto the screen.
  // latex->DrawLatex(0.6,0.2, lum);
  // latex->DrawLatex(0.18,0.87, lum);
  //=========================================================================================================================================================================//
  // P a r a m e t e r   B o x
  // ---------------------------------------------------------------------------
  auto x1 = pad1->GetLeftMargin() + 0.275;  // was 0.30*dx from transforms
  auto x2 = 0.90;
  auto y1 = 1.0 - pad1->GetTopMargin() - 0.30; // a tad lower
  auto y2 = 1.0 - pad1->GetTopMargin() - 0.02;

  auto legend = new TLegend(x1, y1, x2, y2);

  TString chi2("");
  TString N_sig("");
  TString N_DstarP("");
  TString N_Dstar0("");
  TString N_Comb("");

  // chi2.Form("#chi^{2}/ndf = %.2f", chi2ndf);
  // N_sig.Form("N_{sig} = %.2f #pm %.2f", f0.getValV(), f0.getError());
  // N_DstarP.Form("N_{D^{*+}} = %.2f #pm %.2f", f1.getValV(), f1.getError());
  // N_Dstar0.Form("N_{D^{*0}} = %.2f #pm %.2f", f2.getValV(), f2.getError());
  // N_Comb.Form("N_{Comb.} = %.2f #pm %.2f", f3.getValV(), f3.getError());

  chi2.Form("#chi^{2}/ndf = %.2f", chi2ndf);

  N_sig    = FormatYieldSci("N_{sig}",    f0.getValV(), f0.getError(),    1);
  N_DstarP = FormatYieldSci("N_{D^{*+}}", f1.getValV(), f1.getError(),    1);
  N_Dstar0 = FormatYieldSci("N_{D^{*0}}", f2.getValV(), f2.getError(),    1);
  N_Comb   = FormatYieldSci("N_{Comb.}",  f3.getValV(), f3.getError(),    1);

  // Legend
  legend->AddEntry(frame->FindObject("data"),"data","pe");
  legend->AddEntry((TObject *)0, chi2, "");

  //  TString scaledSignal;
  //  scaledSignal.Form("Signal Fit (x%.0f)", scaleFactor);
  //  legend->AddEntry("SignalScaled", scaledSignal, "pl");

  // =================== THEORY reference (for the LABEL only) ===================
  TString kvis_txt = Sci2Sig(K_VIS, 2);  // e.g. "2.7#times10^{5}"
  legend->AddEntry(frame->findObject("sigVis"),
                  Form("#font[132]{Signal #left(#times %s#right)}", kvis_txt.Data()),
                  "l");
  // =============================================================================
  legend->AddEntry((TObject *)0, N_sig, "");

  legend->AddEntry("DstarP", "D^{*+} #rightarrow D^{0} #pi^{+}", "pl" );
  legend->AddEntry((TObject *)0, N_DstarP, "");
  legend->AddEntry("Dstar0", "D^{*0} #rightarrow D^{0} #pi^{0}/#gamma", "pl" );
  legend->AddEntry((TObject *)0, N_Dstar0, "");
  legend->AddEntry("Comb", "Comb.", "pl" );
  // legend->AddEntry((TObject *)0, N_Comb, "");
  legend->AddEntry((TObject *)0, "", "");
  legend->AddEntry("model", "Total Fit", "pl" );
  // // Labels
  // legend->AddEntry(frame->FindObject("data"),"data","pe");
  // legend->AddEntry("Signal", "Signal Fit", "pl" );
  // legend->AddEntry("PeakingBackground", "D^{*+} #rightarrow [D^{0} #rightarrow K^{-} #pi^{+}] #pi^{+}", "pl" );
  // legend->AddEntry("Background", "comb.+failed", "pl" );
  // legend->AddEntry("FSignal", "D^{*0} Background", "pl" );
  // legend->AddEntry("model", "Total Fit", "pl" );

  legend->SetBorderSize(0);
  legend->SetTextFont(132);
  legend->SetTextSize(0.037);
  legend->SetNColumns(2);
  legend->SetMargin(0.10);
  legend->Draw();
  //=========================================================================================================================================================================//
  // S h o w   P a r a m e t e r/ F i t    R e s u l t s
  // -------------------------------------------------------
  // When I use rooworkspace this first part will make sure that the parameters of the 
  // model will stay fixed.
  // N.setConstant(true);
  // N.removeError();
  // b.setConstant(true);
  // b.removeError();
  // P.setConstant(true);
  // P.removeError();

  // Verbose printing: Basic info, values of constant parameters, initial and
  // final values of floating parameters, global correlations
  r->Print("v");

  // Access basic information
  cout << "EDM = " << r->edm() << endl;
  cout << "-log(L) at minimum = " << r->minNll() << endl;

  // Extract covariance and correlation matrix as TMatrixDSym
  const TMatrixDSym &cor = r->correlationMatrix();
  const TMatrixDSym &cov = r->covarianceMatrix();

  // Print correlation, covariance matrix
  cout << "Correlation Matrix" << endl;
  cor.Print();
  cout << "Covariance Matrix" << endl;
  cov.Print();
  //=========================================================================================================================================================================//
  // S h o w   P u l l   d i s t s
  // -------------------------------------------------------
  pad2->cd();
  // Construct a histogram with the residuals of the data w.r.t. the curve
  RooHist *hpull = frame->pullHist();
  for(int iPoint = 0; iPoint < hpull->GetN(); ++iPoint) {
    hpull->SetPointEYlow(iPoint, 0.0);
    hpull->SetPointEYhigh(iPoint, 0.0);
  }
  hpull->SetFillColor(38);
  // hpull->SetLineWidth(-802);
  // hpull->SetFillStyle(3002);
  // hpull->SetFillColor(2);

  // Create a new frame to draw the residual distribution and add the distribution to the frame
  RooPlot *frame1 = x.frame(Title("Pull Distribution"));
  frame1->addPlotable(hpull, "B");
  frame1->Draw();

  pad2->cd();
  frame1->Draw();
  pad2->Modified();
  pad2->Update();

  // Plot Titles
  //---------------
  frame1->SetTitle("");

  // fonts
  frame1->GetYaxis()->SetTitleFont(132);
  frame1->GetYaxis()->SetLabelFont(132);
  frame1->GetXaxis()->SetTitleFont(132);
  frame1->GetXaxis()->SetLabelFont(132);

  // Y (pull)
  frame1->GetYaxis()->SetTitle("Pull");
  frame1->GetYaxis()->CenterTitle(true);
  frame1->GetYaxis()->SetTitleSize(0.16);      // was 0.14
  frame1->GetYaxis()->SetTitleOffset(0.40);    // **pull the title into the pad**
  frame1->GetYaxis()->SetLabelSize(0.10);
  frame1->GetYaxis()->SetNdivisions(505);

  // X (pull)
  // frame1->SetXTitle("#Delta m  #left( D_{s}^{+} - D^{0} #right)  #left[ GeV/c^{2} #right]");
  frame1->SetXTitle("#Delta m_{e}#left(D_{s}^{+} - D^{0}#right)[GeV/c^{2}]");
  frame1->GetXaxis()->CenterTitle(true);
  frame1->GetXaxis()->SetTitleSize(0.16);      // was 0.16
  frame1->GetXaxis()->SetLabelSize(0.11);
  frame1->GetXaxis()->SetTitleOffset(0.80);

  // Draw Horizontal Line On Residual Plot
  //----------------------------------------
  // double xmin1 = xIF1; 
  // double xmax1 = 1.0;
  // TLine *line11 = new TLine(xIF1,0.0,xIF2,0.0);
  // line11->SetLineColor(kRed); line11->SetLineWidth(3);
  // line11->Draw("SAME");

  c->cd();
  //=========================================================================================================================================================================//
  // S a v e   t h e   P l o t 
  //-------------------------------
  c->SaveAs("/home/belle2/amubarak/Ds2D0enue_Analysis/05-ROOT/00-e_fit/Roofit_Ch1/Fit_Image/rf04_DeltaM_Combined.pdf");
  //=========================================================================================================================================================================//
  // ======================= Stat-only BF =========================
  // headers you may need at top of the file:
  // #include <algorithm>  // std::max
  // #include <iomanip>    // std::setprecision, std::scientific
  // #include <sstream>    // std::ostringstream

  // --- Inputs (numbers are your current values) ---
  const double L_full   = 1443.999e15;   // nb^{-1}  (integrated luminosity used for result)
  const double sigma_cc = 1.329e-9;      // nb       (e+e- -> c cbar cross section)
  const double two_fDs  = 0.20;          // 2 * f(c->D_s)
  const double B_D0Kpi  = 0.03947;       // B(D^0 -> K^- pi^+)
  const double eff      = 0.0415181;     // total selection efficiency

  // If you fitted only a subsample, set L_full to that subsample's luminosity
  // and use the fitted yield from that subsample. The formula below is unchanged.

  // --- Fitted yield (allow negative; stat-only error) ---
  f0.setRange(-1e12, +1e12);             // ensure not artificially constrained
  const double Nsig     = f0.getValV();
  const double Nsig_err = f0.getError();

  // --- Denominator (kept fixed for stat-only) ---
  const double denom = L_full * sigma_cc * two_fDs * B_D0Kpi * eff;

  // --- Result (stat only) ---
  const double BF_central = Nsig / denom;          // can be negative
  const double BF_stat    = Nsig_err / denom;      // stat-only uncertainty

  // One-sided upper limits (Gaussian, stat-only)
  const double BF_UL68 = std::max(0.0, BF_central) + 1.000 * BF_stat;
  const double BF_UL90 = std::max(0.0, BF_central) + 1.282 * BF_stat;
  const double BF_UL95 = std::max(0.0, BF_central) + 1.645 * BF_stat;

  // Pretty print in scientific notation
  auto sci = [](double x){
    std::ostringstream s; s.setf(std::ios::scientific);
    s << std::setprecision(3) << x; return s.str();
  };

  std::cout << "\n=== Branching fraction (stat only) ===\n"
            << "BF = " << sci(BF_central) << " ± " << sci(BF_stat) << '\n'
            << "UL (68% one-sided) = " << sci(BF_UL68) << '\n'
            << "UL (90% one-sided) = " << sci(BF_UL90) << '\n'
            << "UL (95% one-sided) = " << sci(BF_UL95) << '\n'
            << std::endl;
  //=========================================================================================================================================================================//
  // Final Fit Status
  //---------------------------
  int fitStatus = r->status();  // Get the fit status
  int covQual = r->covQual();   // Get covariance quality

  std::cout << "Fit Status: " << fitStatus << std::endl;
  std::cout << "Covariance Matrix Quality: " << covQual << std::endl << endl;

}