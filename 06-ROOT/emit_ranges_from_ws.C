// emit_ranges_from_ws.C  — emit ±1-decade-around-value ranges (skip Dstarp_mean)
#include "TFile.h"
#include "RooWorkspace.h"
#include "RooRealVar.h"
#include "RooArgSet.h"
#include "RooAbsArg.h"
#include "TIterator.h"
#include <cmath>
#include <fstream>
#include <iostream>
#include <iomanip>
#include <memory>
#include <string>

static inline double decadeStepFromVal(double v, double fallback=1e-3) {
  double x = std::fabs(v);
  if (x == 0.0) x = std::fabs(fallback);
  if (x == 0.0) x = 1e-3;
  return std::pow(10.0, std::floor(std::log10(x)));
}

static inline bool isFractionName(const std::string& n) {
  if (n.empty()) return false;
  if (n[0] == 'f' || n[0] == 'F') return true;          // f0Dstarp, f1_S, ...
  return n.find("frac") != std::string::npos;
}

static inline bool isNonNegativeName(const std::string& n) {
  // treat these as >= 0.0
  if (isFractionName(n)) return true;
  if (n == "nsig" || n == "nbkg") return true;
  if (n.find("sigma") != std::string::npos) return true;
  if (n.find("alpha") != std::string::npos) return true;
  if (n.size() >= 2 && n.substr(n.size()-2) == "nL") return true;
  if (n.size() >= 2 && n.substr(n.size()-2) == "nR") return true;
  if (n == "k") return true;
  return false;
}

// Usage example (same call signature you used):
// .x emit_ranges_from_ws.C(".../rf01_Dstarplus.root","w_Dstarp","parameters","reference_fit_Dstarp",".../rf01_Dstarplus_ranges.h")
void emit_ranges_from_ws(const char* wsfile,
                         const char* wsname   = "w_Dstarp",
                         const char* setname  = "parameters",
                         const char* snapshot = "reference_fit_Dstarp",
                         const char* outhead  = "rf01_Dstarplus_ranges.h")
{
  std::unique_ptr<TFile> f(TFile::Open(wsfile,"READ"));
  if (!f || f->IsZombie()) { std::cerr << "Cannot open " << wsfile << "\n"; return; }

  auto* w = dynamic_cast<RooWorkspace*>(f->Get(wsname));
  if (!w) { std::cerr << "Workspace " << wsname << " not found.\n"; return; }

  if (w->getSnapshot(snapshot)) w->loadSnapshot(snapshot);

  auto* set = w->set(setname);
  if (!set) { std::cerr << "Set " << setname << " not found.\n"; return; }

  std::ofstream out(outhead);
  if (!out) { std::cerr << "Cannot write " << outhead << "\n"; return; }

  out << "// Auto-generated by emit_ranges_from_ws.C\n";
  out << "// Source: " << wsfile << " [" << wsname << "], snapshot=\"" << snapshot << "\"\n\n";
  out << std::scientific << std::setprecision(6);

  std::unique_ptr<TIterator> it(set->createIterator());
  for (TObject* tobj = it->Next(); tobj; tobj = it->Next()) {
    auto* arg = dynamic_cast<RooAbsArg*>(tobj);
    if (!arg) continue;
    auto* v = dynamic_cast<RooRealVar*>(arg);
    if (!v) continue;

    const std::string name = v->GetName();

    // Never touch the observable
    if (name == "Ds_diff_D0pi") continue;

    // *** Per your request: do NOT touch Dstarp_mean at all. ***
    if (name == "Dstarp_mean") continue;

    const double val = v->getVal();
    const double err = v->hasError() ? v->getError() : 0.0;

    // step = 10^{floor(log10(|val|))}  (your “bump the leading digit up/down by 1” rule)
    const double step = decadeStepFromVal(val, err);

    double lo = val - step;
    double hi = val + step;

    // Clamp for special cases
    if (isFractionName(name)) {
      if (lo < 0.0) lo = 0.0;
      if (hi > 1.0) hi = 1.0;
    }
    if (isNonNegativeName(name)) {
      if (lo < 0.0) lo = 0.0; // you wanted 0.0 for things like alphas, n's, sigmas, etc.
    }

    out << name << ".setVal("   << val << ");\n";
    out << name << ".setRange(" << lo  << ", " << hi << ");\n\n";

    // optional console echo
    std::cout << std::scientific << std::setprecision(6)
              << name << ": val=" << val
              << "  range=[" << lo << ", " << hi << "]  step=" << step << "\n";
  }

  std::cout << "\nWrote range suggestions to: " << outhead << "\n";
}