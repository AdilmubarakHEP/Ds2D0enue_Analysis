#include "RooRealVar.h"
#include "RooDataSet.h"
#include "RooGaussian.h"
#include "RooChebychev.h"
#include "RooAddPdf.h"
#include "RooWorkspace.h"
#include "RooPlot.h"
#include "TCanvas.h"
#include "TAxis.h"
#include "TFile.h"
#include "TH1.h"
using namespace RooFit;

#include "TMath.h"  // keep with your other includes

// Format "(v ± e) × 10^{exp}" using a common exponent from max(|v|,|e|).
// nd = number of decimals on the mantissas. 
// omit10pow0=true hides "×10^{0}" when the exponent is 0.
static TString FormatYieldSci(const char* texName,
                              double val, double err,
                              int nd=1, bool omit10pow0=true)
{
  const double amax = TMath::Max(TMath::Abs(val), TMath::Abs(err));
  const int    exp10 = (amax>0.0) ? (int)TMath::Floor(TMath::Log10(amax)) : 0;
  const double scale = TMath::Power(10.0, exp10);
  const double vm = (scale!=0.0) ? val/scale : 0.0;
  const double em = (scale!=0.0) ? err/scale : 0.0;

  TString vStr, eStr, out;
  vStr.Form("%.*f", nd, vm);
  eStr.Form("%.*f", nd, em);

  if (omit10pow0 && exp10==0) {
    out.Form("%s = (%s #pm %s)", texName, vStr.Data(), eStr.Data());
  } else {
    out.Form("%s = (%s #pm %s) * 10^{%d}",
             texName, vStr.Data(), eStr.Data(), exp10);
  }
  return out;
}

// return "a#times10^{b}" with 'sig' significant figures (TLatex friendly)
static TString Sci2Sig(double v, int sig = 2) {
  if (!(v > 0.0) || !std::isfinite(v)) return "0";
  double av = std::fabs(v);
  int    e  = (int)std::floor(std::log10(av));
  double m  = av / std::pow(10.0, e);

  // round mantissa to 'sig' sig figs
  double r = std::pow(10.0, sig - 1);
  m = std::round(m * r) / r;
  if (m >= 10.0) { m /= 10.0; ++e; }

  // strip trailing zeros
  TString ms; ms.Form("%.*f", sig - 1, m);
  while (ms.EndsWith("0")) ms.Chop();
  if (ms.EndsWith(".")) ms.Chop();

  TString out;
  if (e != 0) out.Form("%s*10^{%d}", ms.Data(), e);
  else        out = ms;
  return out;
}
 
void rf04_Combined()
{
  // S e t u p   t h e   F r a m e   f o r   t h e   P l o t
  //------------------------------------------------------------
  // Canvas & pads
  TCanvas *c = new TCanvas("fit", "fit", 700, 760);

  // 72% top pad (main), 28% bottom pad (pull)
  TPad *pad1 = new TPad("pad1","pad1",0,0.28,1,1);
  TPad *pad2 = new TPad("pad2","pad2",0,0,1,0.28);

  // Main pad: leave room at the top for labels
  pad1->SetTopMargin(0.16);     // was 0.05
  pad1->SetBottomMargin(0.03);  // tighter gap to pull
  pad1->SetLeftMargin(0.15);
  pad1->SetRightMargin(0.06);
  pad1->SetTicks(1,1);

  // Pull pad: smaller top margin so panels “kiss”
  pad2->SetTopMargin(0.02);     // was 0.01
  pad2->SetBottomMargin(0.38);  // keep room for big x-title
  pad2->SetLeftMargin(0.15);
  pad2->SetRightMargin(0.06);
  pad2->SetTicks(1,1);

  pad1->Draw();
  pad2->Draw();
  pad1->cd();
  gStyle->SetOptStat(0);
  gStyle->SetEndErrorSize(0);
  pad1->SetTicks(1,1);
  pad2->SetTicks(1,1);
  //=========================================================================================================================================================================//
  // R e a d   w o r k s p a c e   f r o m   f i l e
  // -----------------------------------------------
  // Open input file with workspace (generated by rf503_wspacewrite)
  TFile *f_Sig = new TFile("/home/belle2/amubarak/Ds2D0enue_Analysis/05-ROOT/01-pi_fit/Roofit_Ch1/Fit_Parameter/rf00_Signal.root");
  TFile *f_Dstarp = new TFile("/home/belle2/amubarak/Ds2D0enue_Analysis/05-ROOT/01-pi_fit/Roofit_Ch1/Fit_Parameter/rf01_Dstarplus.root");
  TFile *f_Dstar0 = new TFile("/home/belle2/amubarak/Ds2D0enue_Analysis/05-ROOT/01-pi_fit/Roofit_Ch1/Fit_Parameter/rf02_Dstar0.root");

  // R e t r i e v e   p d f   f r o m   w o r k s p a c e
  // -----------------------------------------------------------------
  // Signal
  RooWorkspace *w_S = (RooWorkspace *)f_Sig->Get("w_Sig");
  // RooRealVar *M_S = w_S->var("Ds_diff_D0pi");
  RooAbsPdf *SignalModel = w_S->pdf("SignalModel");

  // Peaking Background
  RooWorkspace *w_DstarP = (RooWorkspace *)f_Dstarp->Get("w_Dstarp");
  // RooRealVar *M_PBkg = w_PBkg->var("Ds_diff_D0pi");
  RooAbsPdf *DstarpBkgModel = w_DstarP->pdf("DstarpModel");

  // Combinatorial + Failed Background
  RooWorkspace *w_Dstar0 = (RooWorkspace *)f_Dstar0->Get("w_Dstar0");
  // RooRealVar *M_CFBkg = w_CFBkg->var("Ds_diff_D0pi");
  RooAbsPdf *Dstar0BkgModel = w_Dstar0->pdf("Dstar0Model");

  w_S->loadSnapshot("reference_fit_Signal");
  w_DstarP->loadSnapshot("reference_fit_Dstarp");
  w_Dstar0->loadSnapshot("reference_fit_Dstar0");
  //=========================================================================================================================================================================//
  // I n i t i a l i z a t i o n:
  // --------------------------------------------------------------
  // The lines below initializes all my values
  int bin = 50;
  double xL = 0.15;
  double xR = 0.38;
  //=========================================================================================================================================================================//
  // I m p o r t s   D a t a   f r o m   t r e e   b r a n c h:
  // --------------------------------------------------------------
  TFile *file = new TFile("/group/belle/users/amubarak/03-ML/BkgBDT/Ds2D0e-Generic_Ds_053025_0_All_withBkgBDT.root");
  TTree *tree = (TTree*)file->Get("Dstree");
  //=========================================================================================================================================================================//
  // D a t a:
  // --------------------------------------------------------------
  RooRealVar x("Ds_diff_D0pi", "Mass Difference", xL, xR);
  RooRealVar BS("Ds_BkgBDT", "Background Suppression", 0, 1);
  RooDataSet data("data", "dataset with mass", tree, RooArgSet(x,BS));

  // Apply multiple selection cuts: 
  RooDataSet *filteredData = (RooDataSet*)data.reduce("Ds_BkgBDT >= 0.7");
  //=========================================================================================================================================================================//
  // C r e a t e   C o m b i n e d   M o d e l
  // ------------------------------------------------------------------------------

  // // Signal
  // //=============================
  // // --- base gamma (your parameters & syntax) ---
  // RooRealVar x00_S("x00_S","x00_S", 1.3953e-01, 0.135, 0.142);
  // RooRealVar a0_S ("a0_S","a0_S",  5.7336e-01, 4.7336e-01, 6.7336e-01);
  // RooRealVar b0_S ("b0_S","b0_S",  3.4439e+01, 2.4439e+01, 4.4439e+01);
  // x00_S.setConstant(true);
  // a0_S.setConstant(true);
  // b0_S.setConstant(true);
  // RooFormulaVar x00prime_S("x00prime_S", "@0<@1?@0:@1", RooArgList(x,x00_S));
  // RooFormulaVar gamma0_S  ("gamma0_S",   "@0+1.0",      RooArgList(a0_S));
  // RooFormulaVar beta0_S   ("beta0_S",    "1.0/@0",      RooArgList(b0_S));
  // RooGamma      G0("G0","Gamma0", x, gamma0_S, beta0_S, x00prime_S);

  // // --- a slightly narrower gamma to sharpen the apex ---
  // RooRealVar a1_S ("a1_S","a1_S", 4.6284e+00, 3.6284e+00, 5.6284e+00);   // k = a1_S+1
  // RooRealVar b1_S ("b1_S","b1_S", 7.7741e+01, 6.7741e+01, 8.7741e+01); // beta = 1/b1_S
  // a1_S.setConstant(true);
  // b1_S.setConstant(true);
  // RooFormulaVar gamma1_S("gamma1_S","@0+1.0", RooArgList(a1_S));
  // RooFormulaVar beta1_S ("beta1_S", "1.0/@0", RooArgList(b1_S));
  // RooGamma      G1("G1","Gamma1", x, gamma1_S, beta1_S, x00prime_S);

  // // mix
  // RooRealVar f1_S("f1_S","frac(G1)", 3.0868e-01, 2.0868e-01, 4.0868e-01);
  // f1_S.setConstant(true);
  // RooAddPdf SignalModel("SignalModel","G1+G0", RooArgList(G1,G0), RooArgList(f1_S));

  // // D^*+
  // //=============================
  // RooRealVar Dstarp_mean("Dstarp_mean", "mean of crystal", 1.4551e-01, 1.44e-01, 1.46e-01);
  // RooRealVar Dstarp_sigmaL("Dstarp_sigmaL", "Dstarp_sigmaL", 4.4577e-04, 3.4577e-04, 5.4577e-04);
  // RooRealVar Dstarp_sigmaR("Dstarp_sigmaR", "Dstarp_sigmaR", 5.0232e-04, 4.0232e-04, 6.0232e-04);
  // RooRealVar Dstarp_alphaL("Dstarp_alphaL", "Dstarp_alphaL", 1.4019e+00, 0.4019e+00, 2.4019e+00);
  // RooRealVar Dstarp_alphaR("Dstarp_alphaR", "Dstarp_alphaR", 1.6301e+00, 0.6301e+00, 2.6301e+00);
  // RooRealVar Dstarp_nL("Dstarp_nL", "Dstarp_nL", 3.0230e+00, 2.0230e+00, 4.0230e+00);
  // RooRealVar Dstarp_nR("Dstarp_nR", "Dstarp_nR", 2.1266e+00, 1.1266e+00, 3.1266e+00);
  //  Dstarp_mean.setConstant();
  //  Dstarp_sigmaL.setConstant();
  //  Dstarp_sigmaR.setConstant();
  //  Dstarp_alphaL.setConstant();
  //  Dstarp_alphaR.setConstant();
  //  Dstarp_nL.setConstant();
  //  Dstarp_nR.setConstant();
  // RooCrystalBall DstarpModel("DstarpModel", "sig4", x, Dstarp_mean, Dstarp_sigmaL,Dstarp_sigmaR,Dstarp_alphaL,Dstarp_nL,Dstarp_alphaR,Dstarp_nR);

  // // D^*0
  // //=============================
  // // Base gamma near threshold
  // RooRealVar Dstar0_x00 ("Dstar0_x00","threshold", 1.3956e-01, 0.135, 0.145);
  // RooRealVar Dstar0_a0  ("Dstar0_a0", "a0",        3.6092e-01, 2.6092e-01, 4.6092e-01);
  // RooRealVar Dstar0_b0  ("Dstar0_b0", "b0",        4.1477e+01, 3.1477e+01, 5.1477e+01);
  // Dstar0_x00.setConstant();
  // Dstar0_a0.setConstant();
  // Dstar0_b0.setConstant();
  // RooFormulaVar Dstar0_x00p ("Dstar0_x00p", "@0<@1?@0:@1", RooArgList(x, Dstar0_x00));
  // RooFormulaVar Dstar0_gam0 ("Dstar0_gam0","@0+1.0",      RooArgList(Dstar0_a0));
  // RooFormulaVar Dstar0_bet0 ("Dstar0_bet0","1.0/@0",      RooArgList(Dstar0_b0));
  // RooGamma     Dstar0_G0    ("Dstar0_G0", "Gamma0", x, Dstar0_gam0, Dstar0_bet0, Dstar0_x00p);

  // // Sharpening gamma defined *relative* to the base
  // RooRealVar   Dstar0_dA ("Dstar0_dA","shape increment", 2.2718e+00, 1.2718e+00, 3.2718e+00); // a1 = a0 + dA
  // RooRealVar   Dstar0_sB ("Dstar0_sB","scale ratio",     1.2558e+00, 0.2558e+00, 2.2558e+00); // b1 = sB * b0
  // Dstar0_dA.setConstant();
  // Dstar0_sB.setConstant();
  // RooFormulaVar Dstar0_a1F ("Dstar0_a1F","@0+@1",  RooArgList(Dstar0_a0, Dstar0_dA));
  // RooFormulaVar Dstar0_b1F ("Dstar0_b1F","@0*@1",  RooArgList(Dstar0_b0, Dstar0_sB));
  // RooFormulaVar Dstar0_gam1("Dstar0_gam1","@0+1.0",RooArgList(Dstar0_a1F));
  // RooFormulaVar Dstar0_bet1("Dstar0_bet1","1.0/@0",RooArgList(Dstar0_b1F));
  // RooGamma      Dstar0_G1  ("Dstar0_G1","Gamma1", x, Dstar0_gam1, Dstar0_bet1, Dstar0_x00p);

  // // Mixture
  // RooRealVar Dstar0_f1("Dstar0_f1","frac(G1)", 5.7185e-01, 4.7185e-01, 6.7185e-01);
  // Dstar0_f1.setConstant();
  // RooAddPdf  Dstar0Model("Dstar0Model","G1+G0", RooArgList(Dstar0_G1, Dstar0_G0),
  //                      RooArgList(Dstar0_f1));

  // Comb.
  //=============================
  // RooRealVar a("a", "power shape", 8.8299e-03, 7.8299e-03, 9.8299e-03);          // sharpness of turn-on
  // RooRealVar b("b", "tail weight", 7.3664e-03, 6.3664e-03, 8.3664e-03);           // plateau slope
  // RooRealVar c_shape("c_shape", "width scale", 1.2816e-02, 0.2816e-02, 2.2816e-02);     // saturation scale
  // RooRealVar dm0("dm0", "threshold", 1.1988e-02, 0.1988e-02, 2.1988e-02);  // turn-on
  // a.setConstant(true);
  // b.setConstant(true);
  // c_shape.setConstant(true);
  // dm0.setConstant(true);
  // RooDstD0BG Combinatorial("Combinatorial", "Combinatorial background", x, dm0, c_shape, a, b);

  RooRealVar x00("x00","x00", 1.4250e-01, 0.140, 0.145);
  RooRealVar a0("a0","a0", 5.0133e-01, 4.8e-01, 5.6e-01);
  RooRealVar b0("b0","b0", 3.0000e+00, 2.5, 3.5);    
  x00.setConstant(true);
  a0.setConstant(true);
  b0.setConstant(true);
  RooFormulaVar x00prime("#x00prime", "x[0] < x[1] ? x[0] : x[1]", RooArgList(x, x00));     
  RooFormulaVar gamma0("#gamma0", "a0 + 1", RooArgList(a0));    
  RooFormulaVar beta0_for_gamma("beta0_for_gamma", "1./b0", RooArgList(b0)); 
  RooGamma Combinatorial("Combinatorial", "Gamma pdf", x, gamma0, beta0_for_gamma, x00prime);

  //--------------- Combined Model of signal and generic MC ------------------//
  //--------------------------------------------------------------------------//
  RooRealVar f0("f0", "f0", 0.0, 50.);
  // RooRealVar f1("f1", "f1", 1.5432e+03, 1.0e+03, 2.0e+03);
  // RooRealVar f2("f2", "f2", 1.1560e+04, 1.0e+04, 1.5e+04);

  // Fixed
  RooRealVar f1("f1", "f1", 1.2525e+03, 1.0e+03, 2.0e+03);
  RooRealVar f2("f2", "f2", 1.1305e+04, 1.0e+04, 1.5e+04);
  f1.setConstant(true);
  f2.setConstant(true);

  RooRealVar f3("f3", "f3", 5.5672e+04, 4.5672e+04, 6.5672e+04);
  // f0.setConstant(true);
  // f1.setConstant(true);
  // f2.setConstant(true);
  // f3.setConstant(true);
  RooAddPdf model("model", "s+pbkg+cbkg+fs", RooArgList(*SignalModel,*DstarpBkgModel,*Dstar0BkgModel, Combinatorial), RooArgList(f0,f1,f2,f3));
  //=========================================================================================================================================================================//
  // F i t
  //-------------
  // Perform extended ML fit of data:
  std::unique_ptr<RooFitResult> r{model.fitTo(*filteredData, Save(), PrintLevel(-1))};
  // If the fit is too broad and does not seem to fit a peak use the code below. Use it
  // once to determine where the peak should be and then adjust the mean above.
  // model.fitTo(data, Minos(kTRUE), PrintLevel(-1), Range(2,2.1));
  //=========================================================================================================================================================================//
  // P l o t 
  //---------
  RooPlot* frame = x.frame();
  filteredData->plotOn(frame, Binning(bin));

  // =================== signal overlay (theory OR fit×factor) ========
  constexpr double K_VIS  = 5.0e5;    // pick a value that makes the curve visible
  constexpr double BF_REF = 3e-8;     // theory BF you want to illustrate

  // Inputs (your numbers)
  const double L_nb      = 1.443999e18;  // nb^{-1}  (≈1.444 ab^{-1})
  const double sigma_nb  = 1.329e-9;     // nb
  const double two_f_Ds  = 0.20;         // 2·f(c→Ds)
  const double Br_D0_Kpi = 0.03947;      // B(D0→Kπ)
  const double eff_scal  = 0.0379237;      // signal efficiency for this selection

  // Expected signal yield at BF_REF
  const double N_theory = L_nb * sigma_nb * two_f_Ds * Br_D0_Kpi * eff_scal * BF_REF;

  // ----- Draw ONLY the signal SHAPE, normalized to K_VIS × N_theory -----
  SignalModel->plotOn(frame,
    RooFit::Components("SignalModel"),               // your signal component name
    RooFit::Normalization(K_VIS * N_theory, RooAbsReal::NumEvent),
    RooFit::LineStyle(kDashed),
    RooFit::LineColor(kAzure-2),
    RooFit::Name("sigVis"));
  // =================== individual components (optional) =============

  model.plotOn(frame, Components(*DstarpBkgModel),     LineStyle(kDashed), LineColor(kGreen+1),    RooFit::Name("DstarP"));
  model.plotOn(frame, Components(*Dstar0BkgModel),     LineStyle(kDashed), LineColor(kOrange+8),   RooFit::Name("Dstar0"));
  model.plotOn(frame, Components(Combinatorial),       LineStyle(kDashed), LineColor(kViolet-3),   RooFit::Name("Comb"));

  model.plotOn(frame, LineColor(41), RooFit::Name("model"));
  // *PeakingBkgModel->plotOn(frame, LineColor(38), RooFit::Name("model"));
  //=========================================================================================================================================================================//
  // C a l c u l a t e   c h i ^ 2
  // ------------------------------
  // Show the chi^2 of the curve w.r.t. the histogram
  // If multiple curves or datasets live in the frame you can specify
  // the name of the relevant curve and/or dataset in chiSquare()
  Int_t npar = model.getParameters(*filteredData)->selectByAttrib("Constant",kFALSE)->getSize(); //select floating parameters and count their number

  cout << "NDF = " << npar << endl;
  cout << "chi^2/NDF = " << frame->chiSquare(npar) << endl;

  Double_t chi2ndf = frame->chiSquare(npar);
  //=========================================================================================================================================================================//
  // P l o t    L a b e l s
  // ---------------------------------------------------------------------------
  // // // Add text to frame
  // // TLatex *latex = new TLatex();
  // // TString lum ("");
  // // lum.Form("#splitline{Simulated Events}{2M Events}");
  // // latex->SetNDC();
  // // latex->SetTextSize(0.035);
  // // Add text to frame
  // TLatex *latex = new TLatex();
  // TString lum ("");
  // // lum.Form("#splitline{Simulation}{200k Events}");
  // lum.Form("#splitline{Generic Events}{#scale[0.5]{#int}#it{L} dt=1.4 ab^{-1}}");
  // latex->SetNDC();
  // latex->SetTextSize(0.035); 

  auto PerBin = ((xR-xL)/(bin))*1000;
  // TString title ("");
  TString y_axis ("");
  // TString x_axis ("");

  // title.Form("Generic d#bar{d} Events");
  y_axis.Form("Entries/(%.2f MeV/c^{2})", PerBin);
  // x_axis.Form("#Delta m  [GeV/c^{2}]");

  frame->SetTitle("");

  // ---- Make negative overlay visible if needed ----
  const double maxY = frame->GetMaximum();
  frame->GetYaxis()->SetRangeUser(0.0, 1.35*maxY);   // show a bit below zero

  frame->GetYaxis()->SetTitleFont(132);
  frame->GetYaxis()->SetLabelFont(132);
  frame->GetXaxis()->SetTitleFont(132);
  frame->GetXaxis()->SetLabelFont(132);

  // Y (main)
  frame->GetYaxis()->SetTitle(y_axis);
  frame->GetYaxis()->SetTitleSize(0.060);    // bigger title
  frame->GetYaxis()->SetLabelSize(0.045);    // bigger labels
  frame->GetYaxis()->SetTitleOffset(1.1);   // move left a touch

  // Hide X title/labels on main (they live in the pull panel)
  frame->GetXaxis()->SetTitle("");
  frame->GetXaxis()->SetLabelSize(0.0);

  frame->Draw();

  auto y0 = new TLine(xL, 0.0, xR, 0.0);
  y0->SetLineStyle(kDashed); y0->SetLineColor(kGray+1);
  y0->Draw("same");

  const double xRight = 1.0 - pad1->GetRightMargin() - 0.005;
  const double xLeft  = pad1->GetLeftMargin()  + 0.005;
  const double yBand  = 1.0 - 0.5*pad1->GetTopMargin();  // middle of top margin

  TLatex *latex = new TLatex();
  latex->SetNDC();
  latex->SetTextFont(132);
  latex->SetTextSize(0.060);  // slightly larger

  // Right, top
  latex->SetTextAlign(33);
  latex->DrawLatex(xRight, yBand, "#scale[0.5]{#int}#it{L} dt=1.4 ab^{-1}");

  // Left, top
  latex->SetTextAlign(13);
  latex->DrawLatex(xLeft,  yBand, "Generic Events");

  // The line below prints the luminosity onto the screen.
  // latex->DrawLatex(0.6,0.2, lum);
  // latex->DrawLatex(0.18,0.87, lum);
  //=========================================================================================================================================================================//
  // P a r a m e t e r   B o x
  // ---------------------------------------------------------------------------
  auto x1 = pad1->GetLeftMargin() + 0.1;  // was 0.30*dx from transforms
  auto x2 = 0.92;
  auto y1 = 1.0 - pad1->GetTopMargin() - 0.30; // a tad lower
  auto y2 = 1.0 - pad1->GetTopMargin() - 0.02;

  auto legend = new TLegend(x1, y1, x2, y2);

  TString chi2("");
  TString N_sig("");
  TString N_DstarP("");
  TString N_Dstar0("");
  TString N_Comb("");

  // chi2.Form("#chi^{2}/ndf = %.2f", chi2ndf);
  // N_sig.Form("N_{sig} = %.2f #pm %.2f", f0.getValV(), f0.getError());
  // N_DstarP.Form("N_{D^{*+}} = %.2f #pm %.2f", f1.getValV(), f1.getError());
  // N_Dstar0.Form("N_{D^{*0}} = %.2f #pm %.2f", f2.getValV(), f2.getError());
  // N_Comb.Form("N_{Comb.} = %.2f #pm %.2f", f3.getValV(), f3.getError());

  chi2.Form("#chi^{2}/ndf = %.2f", chi2ndf);

  N_sig    = FormatYieldSci("N_{sig}",    f0.getValV(), f0.getError(),    1);
  N_DstarP = FormatYieldSci("N_{D^{*+}}", f1.getValV(), f1.getError(),    1);
  N_Dstar0 = FormatYieldSci("N_{D^{*0}}", f2.getValV(), f2.getError(),    1);
  N_Comb   = FormatYieldSci("N_{Comb.}",  f3.getValV(), f3.getError(),    1);

  // Legend
  legend->AddEntry(frame->FindObject("data"),"data","pe");
  legend->AddEntry((TObject *)0, chi2, "");

  //  TString scaledSignal;
  //  scaledSignal.Form("Signal Fit (x%.0f)", scaleFactor);
  //  legend->AddEntry("SignalScaled", scaledSignal, "pl");

  // =================== THEORY reference (for the LABEL only) ===================
  TString kvis_txt = Sci2Sig(K_VIS, 2);  // e.g. "2.7#times10^{5}"
  legend->AddEntry(frame->findObject("sigVis"),
                  Form("#font[132]{Signal #left(#times %s#right)}", kvis_txt.Data()),
                  "l");
  // =============================================================================
  legend->AddEntry((TObject *)0, N_sig, "");

  legend->AddEntry("DstarP", "D^{*+} #rightarrow D^{0} #pi^{+}", "pl" );
  legend->AddEntry((TObject *)0, N_DstarP, "");
  legend->AddEntry("Dstar0", "D^{*0} #rightarrow D^{0} #pi^{0}/#gamma", "pl" );
  legend->AddEntry((TObject *)0, N_Dstar0, "");
  legend->AddEntry("Comb", "Comb.", "pl" );
  legend->AddEntry((TObject *)0, N_Comb, "");
  legend->AddEntry("model", "Total Fit", "pl" );
  // // Labels
  // legend->AddEntry(frame->FindObject("data"),"data","pe");
  // legend->AddEntry("Signal", "Signal Fit", "pl" );
  // legend->AddEntry("PeakingBackground", "D^{*+} #rightarrow [D^{0} #rightarrow K^{-} #pi^{+}] #pi^{+}", "pl" );
  // legend->AddEntry("Background", "comb.+failed", "pl" );
  // legend->AddEntry("FSignal", "D^{*0} Background", "pl" );
  // legend->AddEntry("model", "Total Fit", "pl" );

  legend->SetBorderSize(0);
  legend->SetTextFont(132);
  legend->SetTextSize(0.04);
  legend->SetNColumns(2);
  legend->SetMargin(0.10);
  legend->Draw();
  //=========================================================================================================================================================================//
  // S h o w   P a r a m e t e r/ F i t    R e s u l t s
  // -------------------------------------------------------
  // When I use rooworkspace this first part will make sure that the parameters of the 
  // model will stay fixed.
  // N.setConstant(true);
  // N.removeError();
  // b.setConstant(true);
  // b.removeError();
  // P.setConstant(true);
  // P.removeError();

  // Verbose printing: Basic info, values of constant parameters, initial and
  // final values of floating parameters, global correlations
  r->Print("v");

  // Access basic information
  cout << "EDM = " << r->edm() << endl;
  cout << "-log(L) at minimum = " << r->minNll() << endl;

  // Extract covariance and correlation matrix as TMatrixDSym
  const TMatrixDSym &cor = r->correlationMatrix();
  const TMatrixDSym &cov = r->covarianceMatrix();

  // Print correlation, covariance matrix
  cout << "Correlation Matrix" << endl;
  cor.Print();
  cout << "Covariance Matrix" << endl;
  cov.Print();
  //=========================================================================================================================================================================//
  // S h o w   P u l l   d i s t s
  // -------------------------------------------------------
  pad2->cd();
  // Construct a histogram with the residuals of the data w.r.t. the curve
  RooHist *hpull = frame->pullHist();
  for(int iPoint = 0; iPoint < hpull->GetN(); ++iPoint) {
    hpull->SetPointEYlow(iPoint, 0.0);
    hpull->SetPointEYhigh(iPoint, 0.0);
  }
  hpull->SetFillColor(38);
  // hpull->SetLineWidth(-802);
  // hpull->SetFillStyle(3002);
  // hpull->SetFillColor(2);

  // Create a new frame to draw the residual distribution and add the distribution to the frame
  RooPlot *frame1 = x.frame(Title("Pull Distribution"));
  frame1->addPlotable(hpull, "B");
  frame1->Draw();

  pad2->cd();
  frame1->Draw();
  pad2->Modified();
  pad2->Update();

  // Plot Titles
  //---------------
  frame1->SetTitle("");

  // fonts
  frame1->GetYaxis()->SetTitleFont(132);
  frame1->GetYaxis()->SetLabelFont(132);
  frame1->GetXaxis()->SetTitleFont(132);
  frame1->GetXaxis()->SetLabelFont(132);

  // Y (pull)
  frame1->GetYaxis()->SetTitle("Pull");
  frame1->GetYaxis()->CenterTitle(true);
  frame1->GetYaxis()->SetTitleSize(0.16);      // was 0.14
  frame1->GetYaxis()->SetTitleOffset(0.40);    // **pull the title into the pad**
  frame1->GetYaxis()->SetLabelSize(0.10);
  frame1->GetYaxis()->SetNdivisions(505);

  // X (pull)
  // frame1->SetXTitle("#Delta m  #left( D_{s}^{+} - D^{0} #right)  #left[ GeV/c^{2} #right]");
  frame1->SetXTitle("#Delta m_{#pi}#left(D_{s}^{+} - D^{0}#right)[GeV/c^{2}]");
  frame1->GetXaxis()->CenterTitle(true);
  frame1->GetXaxis()->SetTitleSize(0.16);      // was 0.16
  frame1->GetXaxis()->SetLabelSize(0.11);
  frame1->GetXaxis()->SetTitleOffset(0.80);

  // Draw Horizontal Line On Residual Plot
  //----------------------------------------
  // double xmin1 = xIF1; 
  // double xmax1 = 1.0;
  // TLine *line11 = new TLine(xIF1,0.0,xIF2,0.0);
  // line11->SetLineColor(kRed); line11->SetLineWidth(3);
  // line11->Draw("SAME");

  c->cd();
  //=========================================================================================================================================================================//
  // S a v e   t h e   P l o t 
  //-------------------------------
  c->SaveAs("/home/belle2/amubarak/Ds2D0enue_Analysis/05-ROOT/01-pi_fit/Roofit_Ch1/Fit_Image/rf04_DeltaM_Combined.pdf");
  //=========================================================================================================================================================================//
  // ======================= Stat-only BF =========================
  // headers you may need at top of the file:
  // #include <algorithm>  // std::max
  // #include <iomanip>    // std::setprecision, std::scientific
  // #include <sstream>    // std::ostringstream

  // --- Inputs (numbers are your current values) ---
  const double L_full   = 1443.999e15;   // nb^{-1}  (integrated luminosity used for result)
  const double sigma_cc = 1.329e-9;      // nb       (e+e- -> c cbar cross section)
  const double two_fDs  = 0.20;          // 2 * f(c->D_s)
  const double B_D0Kpi  = 0.03947;       // B(D^0 -> K^- pi^+)
  const double eff      = 0.0379237;     // total selection efficiency

  // If you fitted only a subsample, set L_full to that subsample's luminosity
  // and use the fitted yield from that subsample. The formula below is unchanged.

  // --- Fitted yield (allow negative; stat-only error) ---
  f0.setRange(-1e12, +1e12);             // ensure not artificially constrained
  const double Nsig     = f0.getValV();
  const double Nsig_err = f0.getError();

  // --- Denominator (kept fixed for stat-only) ---
  const double denom = L_full * sigma_cc * two_fDs * B_D0Kpi * eff;

  // --- Result (stat only) ---
  const double BF_central = Nsig / denom;          // can be negative
  const double BF_stat    = Nsig_err / denom;      // stat-only uncertainty

  // One-sided upper limits (Gaussian, stat-only)
  const double BF_UL68 = std::max(0.0, BF_central) + 1.000 * BF_stat;
  const double BF_UL90 = std::max(0.0, BF_central) + 1.282 * BF_stat;
  const double BF_UL95 = std::max(0.0, BF_central) + 1.645 * BF_stat;

  // Pretty print in scientific notation
  auto sci = [](double x){
    std::ostringstream s; s.setf(std::ios::scientific);
    s << std::setprecision(3) << x; return s.str();
  };

  std::cout << "\n=== Branching fraction (stat only) ===\n"
            << "BF = " << sci(BF_central) << " ± " << sci(BF_stat) << '\n'
            << "UL (68% one-sided) = " << sci(BF_UL68) << '\n'
            << "UL (90% one-sided) = " << sci(BF_UL90) << '\n'
            << "UL (95% one-sided) = " << sci(BF_UL95) << '\n'
            << std::endl;
  //=========================================================================================================================================================================//
  // Final Fit Status
  //---------------------------
  int fitStatus = r->status();  // Get the fit status
  int covQual = r->covQual();   // Get covariance quality

  std::cout << "Fit Status: " << fitStatus << std::endl;
  std::cout << "Covariance Matrix Quality: " << covQual << std::endl << endl;

}